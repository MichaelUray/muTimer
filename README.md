# muTimer Library #

This library provides a non-blocking timer/delay functionality for Arduinos which consumes not much RAM.

It does not use any hardware timers, it uses the Arduino millis() function to store the start time.\
You can find the source there: https://github.com/MichaelUray/muTimer/ \
MIT license, check LICENSE file for more details.

### About this Library ###

There is often the requirement in a program to wait for a certain time before an action gets taken.
The easiest way to create a delay in a program is probably the function delay(), but with the disadvantage that nothing else can happen in the meanwhile, means the delay() function is blocking other code executions while it is waiting.
```cpp
void loop()
{
  LED1 = 1;
  delay(100)
  LED1 = 0;
  delay(500)
}
```
While the LED is on in this example and the delay(1000) is waiting for its time to elapse, nothing else can happen (except of interrupts).\
The [example](#Example) below shows how a flashing LED can get implemented without blocking other code.

Another disadvantage from the delay() function is, that you cannot use it within interrupts, since the time gets generated by the timer0 interrupt, which does not work as long as you are in another interrupt routine.\
These library functions can get used for example to do any action if an input is active at least for a given time.\
Some application examples for which this library could work for.
- Debounce a switch or button.
- Take any action after a given time permanently, e.g. switch an LED on 5s after the input gets set.
- Take any action after a given time just once, e.g. send a string via the serial interface every 5s.
- Create LED flashing with given on/off interval times.
- Switch a pump on by a floating switch if the switch is true for at least on minute and turn the pump off, if the switch gets false for at least 15s.


# Functions

### Timer Functions ###

**timerOnOff()**\
On and off delay.\
Starts the timer if the bool 'input' gets set and it returns true when the 'on' timer given by 'delayOnTime' in msec is elapsed.\
If the output is already set and you clear the 'input', then it starts the 'off' timer and it returns false when the time given by 'delayOfTime' in msec is elapsed.
```cpp
  bool timerOnOff(bool input, uint32_t delayOnTime, uint32_t delayOffTime);
  
  // example: on delay 2000 ms, off delay 1000 ms
  output1 = myTimer1.timerOnOff(input1, 2000, 1000);
```

**timerOn()**\
On delay only.\
Same as timerOnOff(), but on delay only.
```cpp
  bool timerOn(bool input, uint32_t delayOnTime);
  
  // example: on delay 2000 ms
  output1 = myTimer1.timerOn(input1, 2000);
```

**timerOff()**\
Off delay only.\
Same as timerOnOff(), but off delay only.
```cpp
  bool timerOff(bool input, uint32_t delayOffTime);

  // example: off delay 1000 ms
  output1 = myTimer1.timerOff(input1, 1000);
```

**timerOnOffTrigger()**\
On and off delay with output trigger.\
The output gets just set once if the timer elapses.
```cpp
  bool timerOnOffTrigger(bool input, uint32_t delayOffTime);

  // example: on delay 2000 ms, off delay 1000 ms
  if (myTimer1.timerOnOffTrigger(input1, 2000, 1000))
  { // timer elapsed - gets executed just once
    if (input1)
    {
      Serial.println("Timer on finished: input1 == 1");
    }
    else
    {
      Serial.println("Timer off finished: input1 == 0");
    }
  }
```

**timerOnTrigger()**\
On delay only with output trigger.\
The output gets just set once if the timer elapses.
```cpp
  bool timerOnTrigger(bool input, uint32_t delayOffTime);

  // example: on delay 2000 ms
  if (myTimer1.timerOnTrigger(input1, 2000))
  { // timer elapsed - gets executed just once
    Serial.println("Timer on finished: input1 == 1");
  }
```

**timerOffTrigger()**\
Off delay only with output trigger.\
The output gets just set once if the timer elapses.
```cpp
  bool timerOffTrigger(bool input, uint32_t delayOffTime);

  // example: off delay 2000 ms
  if (myTimer1.timerOffTrigger(input1, 2000))
  { // timer elapsed - gets executed just once
    Serial.println("Timer on finished: input1 == 0");
  }
```

### Timer Control ###
**timerReset()**\
Restarts the time from 0 and sets output != input at next timer function call.
```cpp
    void timerReset(void);
```

**timerElapse()**\
Ends the current running timer interval and sets output == input at next timer function call.
```cpp
    void timerElapse(void);
```

### Timer Information ###

**timerIsRunning()**\
Returns true if timer is still running.
```cpp
    bool timerIsRunning(void);
```
**getTimeElapsed()**\
Returns the elapsed time since the start of the timer.
```cpp
    uint32_t getTimeElapsed(void);
```

## Example ##

```cpp
/*
 * Example ButtonAndLedBlinkingTimerOnOff.ino for muTimer library.
 * Library source: https://github.com/MichaelUray/muTimer
 * 
 * This example creates a blinking LED if the input button gets pressed.
 * 
 * The library calls are non-blocking, means other code can get executed while the time duration is running.
 * 
 */

#include <muTimer.h>

muTimer myTimer1 = muTimer();

// processor pin definitions
#define PIN_BUTTON 3
#define PIN_LED 9

// pin status read from input
bool input1;

// output written to hardware output pin
bool output1;

void setup()
{
  // configure input hardware pin with internal pull-up resistor, button has to switch against GND
  pinMode(PIN_BUTTON, INPUT_PULLUP);

  // configure output hardware pin
  pinMode(PIN_LED, OUTPUT);
}

void loop()
{
  // read input (button) from hardware (input is inverted since internal pull-up resistor gets used)
  input1 = !digitalRead(PIN_BUTTON);

  // starts blinking if input is true
  if (input1)
  {
    // on delay 500ms, off delay 100ms
    // means the LED flashes 100ms and is then 500ms off
    output1 = myTimer1.timerOnOff(!output1, 500, 100);
  }
  else
  {
    output1 = 0;
  }
  
  // write output (LED) to hardware
  digitalWrite(PIN_LED, output1);


  // functions are non-blocking
  // other code can get executed there in the meanwhile
  // ...
  
}
```

